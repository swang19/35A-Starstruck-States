#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  liftHookSolenoid, sensorDigitalOut)
#pragma config(Sensor, dgtl3,  armLimit,       sensorDigitalIn)
#pragma config(Sensor, dgtl4,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl5,  liftLockSolenoid, sensorDigitalOut)
#pragma config(Sensor, dgtl6,  wheelyBar,      sensorDigitalOut)
#pragma config(Sensor, I2C_1,  rightDrive_,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftDrive_,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           upLeftArm,     tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           pDriveFR,      tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           pDriveBR,      tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port4,           lowerLeftArm,  tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           upperLeftArm,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           pDriveFL,      tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,           pDriveBL,      tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port8,           lowerRightArm, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           upperRightArm, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          upRightArm,    tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#define POWER_EXPANDER_A1
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#pragma systemFile

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "CKGeneral.h"

//If you want to find this location, Ctrl f autonState
#define auton 4
/**
N.B.:
1. rightAuton(non existent -- use leftAuton)
2. leftAuton
3. Test Thing... Don't use unless you know what you are doing
4. ProgSkills
**/

bool autoClawRunning = false;

int armkp = 1;

//arm functions
void moveArm(int speed)
{
	motor[lowerRightArm] = motor[upperRightArm] = motor[lowerLeftArm] = motor[upperLeftArm] = motor[upLeftArm] = motor[upRightArm] = speed;
}

void raiseArmPot(int potValue,int armSpeed)
{
	while(SensorValue[armPot] < potValue)
	{
		moveArm(armSpeed);
	}
	moveArm(0);
}

//drive functions
int readEncoder(int port){
	//return SensorValue[port];
	return nMotorEncoder[port];
}

void setDrive(int leftSpeed, int rightSpeed)
{
	motor[pDriveFR] = motor[pDriveBR] = rightSpeed;
	motor[pDriveFL] = motor[pDriveBL] = leftSpeed;
}

void setLeftDrive(int leftSpeed) //for p move forward
{
	motor[pDriveFL] = motor[pDriveBL] = leftSpeed;
}

void setRightDrive(int rightSpeed) //for p move forward
{
	motor[pDriveFL] = motor[pDriveBL] = rightSpeed;
}

void turnRight(int time)
{
	setDrive(127, -127);
	wait1Msec(time);
	setDrive(0, 0);
}

void turnLeft(int time)
{
	setDrive(-127, 127);
	wait1Msec(time);
	setDrive(0, 0);
}

const float wheelDiameter = 10.4;//cm

int ticksForInches(float inches){
	return (int)round(inches*360.0/(wheelDiameter*PI/2.54));
}

void resetDriveEncoder()
{
	SensorValue[pDriveBL] = 0;
	SensorValue[pDriveBR] = 0;
}

void PDrive(float driveDistance)
{
	resetDriveEncoder();
	clearDebugStream();
	int error = 0;
	int leftDriven = 0;
	int rightDriven = 0;
	int goalDistance = ticksForInches(driveDistance);
	float Kp = 0.1;
	bool isLeftDone = leftDriven > goalDistance;
	bool isRightDone = rightDriven > goalDistance;
	int basePower = 127;
	while (!isLeftDone || !isRightDone)
	{
		leftDriven = readEncoder(pDriveBL);
		rightDriven = readEncoder(pDriveBR);
		error = leftDriven - rightDriven;
		isLeftDone = leftDriven > goalDistance;
		isRightDone = rightDriven > goalDistance;
		int offset = bound((int)round(Kp * error), -20, 20);
		int leftSpeed = isLeftDone ? 0 : basePower - offset;
		int rightSpeed = isRightDone ? 0 : basePower - offset;
		setDrive(leftSpeed, rightSpeed);
		if (isLeftDone)
			writeDebugStreamLine("Left Done");
		if (isRightDone)
			writeDebugStreamLine("Right Done");
		delay(100);
	}
	writeDebugStreamLine("Drive Complete");
	setLeftDrive(0);
	setRightDrive(0);
}

void PDriveBack(float driveDistance)
{
	resetDriveEncoder();
	int error = 0;
	int leftDriven = 0;
	int rightDriven = 0;
	int goalDistance = ticksForInches(driveDistance);
	float Kp = 0.1;
	bool isLeftDone = leftDriven < goalDistance;
	bool isRightDone = rightDriven < goalDistance;
	int basePower = -127;
	while (!isLeftDone || !isRightDone)
	{
		leftDriven = readEncoder(pDriveBL);
		rightDriven = readEncoder(pDriveBR);
		error = leftDriven - rightDriven;
		isLeftDone = leftDriven < goalDistance;
		isRightDone = rightDriven < goalDistance;
		int offset = bound((int)round(Kp * error), -20, 20);
		int leftSpeed = isLeftDone ? 0 : basePower + offset;
		int rightSpeed = isRightDone ? 0 : basePower + offset;
		setDrive(leftSpeed, rightSpeed);
		if (isLeftDone)
			writeDebugStreamLine("Left Done");
		if (isRightDone)
			writeDebugStreamLine("Right Done");
		delay(100);
	}
	writeDebugStreamLine("Drive Complete");
	setLeftDrive(0);
	setRightDrive(0);
}

//test encoders
void calibrateEncoders()
{
	resetDriveEncoder();
	while (readEncoder(pDriveBL) < 24)
	{
		motor[pDriveBL] = motor[pDriveBR] = motor[pDriveFL] = motor[pDriveFR] = 127;
		writeDebugStreamLine("%i", readEncoder(pDriveBL));
	}
	setDrive(0, 0);
}

//test encoders
void readEncoderValue()
{
	clearDebugStream();
	while (true)
	{
		writeDebugStreamLine("Right: %i", readEncoder(pDriveBR));
		writeDebugStreamLine("Left: %i", readEncoder(pDriveBL));
	}
}

void resetGyro(){
	SensorType[in2] = sensorNone;
	wait1Msec(1000);

	SensorType[in2] = sensorGyro;
	wait1Msec(2000);
}

void testGyro(){
	clearDebugStream();
	while (true)
	{
		writeDebugStreamLine("%f", SensorValue[gyro]);
	}
}

void gyroTurn(int degrees){
	resetGyro();
	int direction = degrees / abs(degrees);
	int degrees10 = degrees * 10 * direction - 120;
	int error = 5; //acceptable error in turn
	while(abs(SensorValue[in2]) < degrees10 - 200)
	{
		setDrive(-70 * direction, 70 * direction);
		//motor[pDriveFR] = 70;
		//motor[pDriveBR] = 70;
		//motor[pDriveFL] = -70;
		//motor[pDriveBL] = -70;
	}
	setDrive(50 * direction, -50 * direction);
	//motor[pDriveFR] = -50;
	//motor[pDriveBR] = -50;
	//motor[pDriveFL] = 50;
	//motor[pDriveBL] = 50;
	wait1Msec(250);
	setDrive(0,0);
	//while(abs(SensorValue[in2]) > degrees10 + error || abs(SensorValue[in2]) < degrees10 - error)
	//{
	//	//???? There is a function for all of this
	//	if(abs(SensorValue[in2]) > degrees10)
	//	{
	//		setDrive(30 * direction, -30 * direction);
	//		//motor[pDriveFR] = -30;
	//		//motor[pDriveBR] = -30;
	//		//motor[pDriveFL] = 30;
	//		//motor[pDriveBL] = 30;
	//	}
	//	else
	//	{
	//		setDrive(-30 * direction, 30 * direction);
	//		//motor[pDriveFR] = 30;
	//		//motor[pDriveBR] = 30;
	//		//motor[pDriveFL] = -30;
	//		//motor[pDriveBL] = -30;
	//	}
	//}
	//setDrive(0, 0);
	//wait1Msec(250);
}

int joyDeadZone(int channel)
{
	int power = vexRT[channel];
	return abs(power) <= 20 ? 0 : power;
}


void moveClaw(int state)
{
	SensorValue[solenoid] = state;
}

int buttonToPower(int channelUp, int channelDown, int onPower, int offPower)
{
	return vexRT[channelDown] ? -1 * onPower : vexRT[channelUp] ? onPower : offPower;
}

int solenoidSwitch(int upButton, int downButton, int defaultValue)
{
	if (vexRT[upButton])
	{
		return 1;
	}
	else if (vexRT[downButton])
	{
		return 0;
	}
	else
	{
		return defaultValue;
	}
}

void setWheelyBar(int state)
{
	SensorValue[wheelyBar] = state;
}

void setLiftLock(int state)
{
	SensorValue[liftLockSolenoid] = state;
	//wait1Msec(100);
}

void setLiftHook(int state)
{
	SensorValue[liftHookSolenoid] = state;
	//wait1Msec(100);
}

void fwd(int time)
{
	setDrive(127, 127);
	wait1Msec(time);
	setDrive(0, 0);
}

void bwd(int time)
{
	setDrive(-127, -127);
	wait1Msec(time);
	setDrive(0, 0);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          				Auton Functions
//
// Different auton functions. Ex. Skills
//
/////////////////////////////////////////////////////////////////////////////////////////

task autoClaw()
{
	autoClawRunning = true;
	if (SensorValue[armPot] < 3400)
	{
		while (true)
		{
			moveArm(127);
			moveClaw(1);
			if (SensorValue[armPot] >= 3400)
			{
				moveClaw(0);
				wait1Msec(100);
				break;
			}
		}
	}
	autoClawRunning = false;
}

task armlessAutoClaw()
{
	if (SensorValue[armPot] < 3400)
	{
		autoClawRunning = true;
		while (true)
		{
			moveClaw(1);
			if (SensorValue[armPot] >= 3400)
			{
				moveClaw(0);
				break;
			}
		}
		wait1Msec(500);
		autoClawRunning = false;
	}
}

void rightAuton(){
}

void leftAuton(){
	setWheelyBar(1);
	moveClaw(0);
	wait1Msec(1000);
	//PDrive(24);
	fwd(1250);
	moveClaw(1);
	moveArm(127);
	wait1Msec(200);
	moveArm(30);
	turnRight(650);
	//gyroTurn(-135);
	setDrive(-127, -127);
	wait1Msec(350);
	startTask(autoClaw);
	while (autoClawRunning == true)
	{
	}
	//setDrive(0, 0);
	while (SensorValue[armPot] > 1300)
	{
		moveArm(-127);
	}
	moveArm(0);
	setDrive(0, 0);
	//PDrive(30);
	fwd(1500);
	moveClaw(1);
	wait1Msec(300);
	moveArm(30);
	bwd(1250);
	startTask(autoClaw);
	while (autoClawRunning == true)
	{
	}
	wait1Msec(300);
	while (SensorValue[armPot] > 1300)
	{
		moveArm(-127);
	}
	moveArm(0);
}

void ProgSkills(){
	bwd(250);
	moveClaw(0);
	wait1Msec(1500);
	for(int i = 0; i < 4; i++){
		moveClaw(1);
		wait1Msec(1000);
		moveArm(30);
		setDrive(-127, -127);
		wait1Msec(1000);
		startTask(autoClaw);
		while (autoClawRunning == true)
		{
		}
		setDrive(0, 0);
		wait1Msec(500);
		while (SensorValue[armPot] > 1300)
		{
			moveArm(-127);
		}
		moveArm(0);
		wait1Msec(750);
		if (i == 3)
		{
			break;
		}
		fwd(1000);
		wait1Msec(1000);
	}
	turnLeft(250);
	moveClaw(0);
	wait1Msec(1000);
	fwd(750);
	moveClaw(1);
	moveArm(30);
	turnRight(350);
	setDrive(-127, -127);
	wait1Msec(350);
	startTask(autoClaw);
	while (autoClawRunning == true)
	{
	}
	setDrive(0, 0);
	while (SensorValue[armPot] > 1300)
	{
		moveArm(-127);
	}
	moveArm(0);
	fwd(1200);
	moveClaw(1);
	wait1Msec(300);
	moveArm(30);
	bwd(1000);
	startTask(autoClaw);
	while (autoClawRunning == true)
	{
	}
	wait1Msec(300);
	while (SensorValue[armPot] > 1300)
	{
		moveArm(-127);
	}
	moveArm(0);
	//turnRight(180); //turn 180 to have front face wall
	//setDrive(-127, -127);
	//wait1Msec(350); //align to wall
	//fwd(500);
	//turnRight(100); // turn a little to align on center cube
	//fwd(1000);
	//moveClaw(1);
	//turnRight(135);
	//setDrive(-127, -127);
	//wait1Msec(350);
	//startTask(autoClaw);
	//while (autoClawRunning == true)
	//{
	//}
	//setDrive(0, 0);
	//turnRight(180);
	//setDrive(-127,-127);
	//wait1Msec(350);
}

void tempCase()
{
	PDrive(24);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////


void pre_auton()
{
	moveClaw(1);
	setWheelyBar(1);
	setLiftHook(1);
	setLiftLock(1);
	resetDriveEncoder();
	resetGyro();

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	switch(auton)
	{
	case 1:
		rightAuton();
		break;

	case 2:
		leftAuton();
		break;

	case 3: //testing case
		tempCase();
		break;

	case 4:
		ProgSkills();
		break;

	case 5:
		turnLeft(500);
		break;

	default:
		rightAuton();
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	//startTask(maintainArmPos);

	bool doHoldArm = false;
	int liftLock = 1;
	int liftHook = 1;
	int initiateLock = 0;
	unsigned long lastLiftHookToggle = 0;
	unsigned long lastLiftLockToggle = 0;
	const unsigned long ToggleDebounce = 400; // ms to wait between togglability.
	setLiftLock(1);
	moveClaw(0);
	setLiftHook(1);
	wait1Msec(500);
	while (true)
	{
		setDrive(joyDeadZone(Ch3), joyDeadZone(Ch2));

		if (autoClawRunning == false)
		{
			moveClaw(solenoidSwitch(Btn6UXmtr2, Btn6DXmtr2, 0));
		}

		setWheelyBar(solenoidSwitch(Btn7U, Btn7D, 0));

		if (vexRT[Btn7UXmtr2] && nPgmTime > lastLiftLockToggle + ToggleDebounce) {
			liftLock = !liftLock;
			setLiftLock(liftLock);
			lastLiftLockToggle = nPgmTime;
		}

		if (vexRT[Btn8UXmtr2] && nPgmTime > lastLiftHookToggle + ToggleDebounce) {
			liftHook = !liftHook;
			setLiftHook(liftHook);
			lastLiftHookToggle = nPgmTime;
		}

		if (vexRT[Btn8DXmtr2]){
			initiateLock = !initiateLock;
		}
		int armState = SensorValue[armLimit];
		if(initiateLock == 1 && armState == 1){
			setLiftLock(1);
		}


		int armSpeed = doHoldArm ? SensorValue[armPot] > 1200 ? 20 : 30 : buttonToPower(Btn6U, Btn6D, 127, 0);
		moveArm(armSpeed);

		if((vexRT[Btn6U] || vexRT[Btn6D]) && doHoldArm){
			doHoldArm = false;
		}
		else if(vexRT[Btn5U] && !doHoldArm){
			doHoldArm = true;
			raiseArmPot(1200,127);
			moveArm(28);
		}

		if (vexRT[Btn5UXmtr2] && autoClawRunning == false)
		{
			startTask(autoClaw);
		}

		if (vexRT[Btn5D])
		{
			startTask(armlessAutoClaw);
		}

		wait1Msec(50);


	}
}
